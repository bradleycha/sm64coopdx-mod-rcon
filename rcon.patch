Copyright (c) Chase Bradley 2025

diff --git a/Makefile b/Makefile
index 0fc235b8e..0369bb0ce 100644
--- a/Makefile
+++ b/Makefile
@@ -965,6 +965,9 @@ else
   LDFLAGS += -Llib/lua/linux -l:liblua53.a -ldl
 endif
 
+# OpenSSL for Lua cryptographic API
+LDFLAGS += -lssl -lcrypto
+
 # CoopNet
 COOPNET_LIBS :=
 ifeq ($(COOPNET),1)
diff --git a/autogen/lua_definitions/manual.lua b/autogen/lua_definitions/manual.lua
index 76ad0d265..7be6dbecf 100644
--- a/autogen/lua_definitions/manual.lua
+++ b/autogen/lua_definitions/manual.lua
@@ -277,6 +277,18 @@ function network_send_to(toLocalIndex, reliable, dataTable)
     -- ...
 end
 
+--- @param message string The chat message to send
+--- Sends a chat message from your local player.
+function send_chat_message(message)
+    -- ...
+end
+
+--- @param bytes string The bytes to digest for the SHA256 hash
+--- Hashes a string of bytes with the SHA256 hash function
+function crypto_hash_sha256(bytes)
+   -- ...
+end
+
 --- @param textureName string The texture name
 --- @return TextureInfo
 --- Gets the `TextureInfo` of a texture by name
diff --git a/src/pc/lua/smlua_functions.c b/src/pc/lua/smlua_functions.c
index 86f51191a..0c9631ad5 100644
--- a/src/pc/lua/smlua_functions.c
+++ b/src/pc/lua/smlua_functions.c
@@ -2,6 +2,7 @@
 #include "smlua_cobject.h"
 
 #include <PR/gbi.h>
+#include <openssl/evp.h>
 
 #include "game/level_update.h"
 #include "game/area.h"
@@ -21,6 +22,8 @@
 #include "game/hardcoded.h"
 #include "gfx_symbols.h"
 #include "include/macros.h"
+#include "pc/debuglog.h"
+#include "pc/chat_commands.h"
 
 bool smlua_functions_valid_param_count(lua_State* L, int expected) {
     int top = lua_gettop(L);
@@ -295,6 +298,49 @@ int smlua_func_network_send_to(lua_State* L) {
     return 1;
 }
 
+int smlua_func_send_chat_message(lua_State* L) {
+    if (!smlua_functions_valid_param_count(L, 1)) { return 0; }
+
+    const char* message = smlua_to_string(L, 1);
+    if (!gSmLuaConvertSuccess) { LOG_LUA("send_chat_message: Failed to convert parameter 1 for function"); return 0; }
+
+    // i'm not sure why this has to be mutable, but sure, i'll play along.
+    char* buffer = strdup(message);
+
+    if (buffer[0] == '/') {
+        exec_chat_command(buffer);
+    } else {
+        network_send_chat(buffer, gNetworkPlayerLocal->globalIndex);
+    }
+
+    free(buffer);
+
+    return 1;
+}
+
+int smlua_func_crypto_hash_sha256(lua_State* L) {
+    if (!smlua_functions_valid_param_count(L, 1)) { return 0; }
+
+    const char* data = smlua_to_string(L, 1);
+    if (!gSmLuaConvertSuccess) { LOG_LUA("crypto_hash_sha256: Failed to convert parameter 1 for function"); return 0; }
+
+    size_t dataBytes = strlen(data);
+
+    char digest[EVP_MAX_MD_SIZE + 1];
+    unsigned int digestLength = 0;
+
+    EVP_MD_CTX *ctx = EVP_MD_CTX_create();
+    EVP_DigestInit(ctx, EVP_sha256());
+    EVP_DigestUpdate(ctx, data, dataBytes);
+    EVP_DigestFinal(ctx, (unsigned char *)digest, &digestLength);
+    digest[digestLength] = '\0';
+    EVP_MD_CTX_free(ctx);
+
+    lua_pushstring(L, digest);
+
+    return 1;
+}
+
 int smlua_func_set_exclamation_box_contents(lua_State* L) {
     if (!smlua_functions_valid_param_count(L, 1)) { return 0; }
 
@@ -1268,6 +1314,8 @@ void smlua_bind_functions(void) {
     smlua_bind_function(L, "reset_level", smlua_func_reset_level);
     smlua_bind_function(L, "network_send", smlua_func_network_send);
     smlua_bind_function(L, "network_send_to", smlua_func_network_send_to);
+    smlua_bind_function(L, "send_chat_message", smlua_func_send_chat_message);
+    smlua_bind_function(L, "crypto_hash_sha256", smlua_func_crypto_hash_sha256);
     smlua_bind_function(L, "set_exclamation_box_contents", smlua_func_set_exclamation_box_contents);
     smlua_bind_function(L, "get_exclamation_box_contents", smlua_func_get_exclamation_box_contents);
     smlua_bind_function(L, "get_texture_info", smlua_func_get_texture_info);
